---
title: shell中的各种括号的作用 $()、${}、[]、[[]]、(())等
permalink: shell-symbol
date: 2020-03-08
tags: Linux
---

`shell`中有很多长相相似的括号命令，经常弄混，特此整理它们各自的作用。

<!--more-->

## $()

用于执行命令并获取命令的结果

```bash
$ echo echo test //第二个echo无法执行，而是被当作字符串
echo test
```

```bash
$ echo $(echo test) //括号内的echo被执行，整个表达式$(echo test)的结果为test，然后第一个echo命令继续执行，参数为test
test
```

另一种执行命令的方式是用反引号 ``

```bash
$ echo `echo test`
```

用反引号的移植性更好，基本所有的`shell`都支持这种方式，而`$()`方式的可读性更好

## ${}

用于解析变量及精确界定变量名称的范围

```bash
$ name=test
$ echo $name
test
$ echo $name2    //预期输出test2，但是输出为空，shell认为此时的变量名为name2，而name2未定义

$ echo ${name}2  //使用${name}明确界定出了变量name的变量名范围，与2构成test2字符串
test2
```

## []

等同于`test`命令，用于判断给定的表达式是否成立

```bash
$ [1 -eq 2]
zsh: bad pattern: [1
```

使用`[]`时，左括号的右侧和右括号的左侧必须有一个以上的空格，不然会报错

```bash
$ [ 1 > 2 ]	//会在当前目录生成一个名为2的文件
$ [ 1 < 2 ] //会尝试读取名为2的文件，若不存在则会报错，若存在此表达式被判断为真
```

```bash
$ [ 1 \> 2 ]
$ [ 1 \< 2 ]
```

若使用`>`及`<`则必须进行转译，不然会被认为是重定向

## [[]]

`[[]]`是`test`及`[]`命令的增强版，增加了一个字符串表达式`string=~regex`

```bash
$ [[ "test" =~ ^-?[0-9]+$ ]]
```



在`[[]]`中使用`<`和`>`，不需要转译

在`[[]]`中的`==`支持模式匹配

```bash
$ file=test.txt
$ [[ $file == test.* ]]
```

## (())

`(())`是为整数设计的，只能用于处理整数

```bash
$ (( "" == "t" )) 	//报错
$ (( 1 == 2 ))			//false
```

与`[[]]`类似，`(())`中使用`<`和`>`也是不需要转译的

## $[]与$(())

`$[]`与`$(())`是相同的，都是用于数学运算

```bash
//这里的左括号右边与右括号左边的空格不是必须的
$ echo $(( (5+1)/2%2 ))
1
$ echo $[ (5+1)/2%2 ]
1
```

默认的输出结果为十进制，`$(())`还可以进行不同进位的运算（二进制、八进制、十六进制等转为十进制），指定进制及数值，输出其十进制的值

```bash
//$(( 进制#数值 ))
$ echo $(( 2#10 )) //2
$ echo $(( 8#12 )) //10
$ echo $(( 16#B )) //11
```

